{"version":3,"file":"umd.js","sources":["../src/if-const.ts","../src/index.ts"],"sourcesContent":["export type Falsy = null | undefined | false | 0 | '';\r\n\r\nexport type F<T, R, U = Falsy> = (res: Exclude<T, U>) => R;\r\nexport type ELF<T, R, U = Falsy> = (res: Extract<T, U>) => R;\r\n\r\ntype FP<T, R> = [f?: F<T, R>, elf?: ELF<T, R>];\r\n\r\ntype FT<T, R> = (...args: FP<T, R>) => R | undefined;\r\n\r\ntype IfConst<U = Falsy> = {\r\n  /**\r\n   * Remembers the value to check later with a comparator\r\n   *\r\n   * @param value - the value to lazily check later\r\n   * @returns a function that accepts two checking branches\r\n   */\r\n  <T>(value: T): {\r\n    /**\r\n     * Checks if the value is truthy for current comparator.\r\n     * If it is, then the callback is executed.\r\n     *\r\n     * If a callback returns a value,\r\n     * it will be passed on as the return value of the whole function.\r\n     *\r\n     * The function will return `undefined` otherwise.\r\n     *\r\n     * @param f - a callback to execute if comparator yields true\r\n     * @returns value returned from f, or `undefined`\r\n     */\r\n    <R>(f: F<T, R, U>): R | undefined\r\n    /**\r\n     * Checks if the value is truthy for current comporator.\r\n     * One of the two callbacks is executed based on the result.\r\n     *\r\n     * If a callback returns a value,\r\n     * it will be passed on as the return value of the whole function.\r\n     *\r\n     * @param f - a callback to execute if comparator yields true\r\n     * @param elf - a callback to execute if comparator yields false\r\n     * @returns value returned from f or elf\r\n     */\r\n    <R>(f: F<T, R, U>, elf: ELF<T, R, U>): R;\r\n  }\r\n  /**\r\n   * Checks if the value is truthy for current comparator.\r\n   * If it is, then the callback is executed.\r\n   *\r\n   * If a callback returns a value,\r\n   * it will be passed on as the return value of the whole function.\r\n   *\r\n   * The function will return `undefined` otherwise.\r\n   *\r\n   * @param value - the value to check against the comparator\r\n   * @param f - a callback to execute if comparator yields true\r\n   * @returns value returned from f, or `undefined`\r\n   */\r\n  <T, R>(value: T, f: F<T, R, U>): R | undefined;\r\n  /**\r\n   * Checks if the value is truthy for current comporator.\r\n   * One of the two callbacks is executed based on the result.\r\n   *\r\n   * If a callback returns a value,\r\n   * it will be passed on as the return value of the whole function.\r\n   *\r\n   * @param value - the value to check against the comparator\r\n   * @param f - a callback to execute if comparator yields true\r\n   * @param elf - a callback to execute if comparator yields false\r\n   * @returns value returned from f or elf\r\n   */\r\n  <T, R>(value: T, f: F<T, R, U>, elf: ELF<T, R, U>): R;\r\n  <T, R>(value: T, f?: F<T, R, U>, elf?: ELF<T, R, U>): R | undefined;\r\n}\r\n\r\ntype Comparator = (val: any) => boolean;\r\n\r\ntype CompThis = { check: Comparator };\r\n\r\nconst defaultComp: Comparator = (val: any) => !!val;\r\n\r\nfunction _ifConst<T, R>(this: CompThis, cond: T, ...args: FP<T, R>): FT<T, R> | R | undefined {\r\n  return args[0]\r\n    ? (this.check(cond) ? args[0] : args[1])?.(cond as any)\r\n    : _ifConst.bind(this, cond as unknown) as FT<T, R>;\r\n}\r\n\r\nexport const ifConst: IfConst & {\r\n  /**\r\n   * Changes the default comparator\r\n   * to one that checks if the input is not equal (`!==`)\r\n   * to the passed value.\r\n   *\r\n   * Serves as a way to type-safely inject a new comparator into the `ifConst` function.\r\n   *\r\n   * @param value - the value to negatively check against\r\n   * @returns IfConst - with the new comparator in-place\r\n   */\r\n  not<U>(value: U): IfConst<U>;\r\n\r\n  /**\r\n   * Changes the default comparator\r\n   * to one that checks if the passed function yields true\r\n   * for the current input.\r\n   *\r\n   * Serves as a way to type-safely inject a new comparator into the `ifConst` function.\r\n   *\r\n   * @param comparator - the function to use as a new comparator\r\n   * @returns IfConst - with the new comparator in-place\r\n   */\r\n  compare<U>(comparator: Comparator): IfConst<U>;\r\n} = _ifConst.bind({ check: defaultComp }) as any;\r\n\r\nifConst.compare = <U>(c: Comparator): IfConst<U> => {\r\n  return _ifConst.bind({ check: c }) as any;\r\n}\r\nifConst.not = <U>(value: U): IfConst<U> => {\r\n  return _ifConst.bind({ check: (_: U) => _ !== value }) as any;\r\n}\r\n","import { ifConst, F, ELF } from './if-const';\n\nexport * from './if-const';\n\nexport default ifConst;\n\nexport function constIf<T, R>(f: F<T, R>): (cond: T) => R | undefined;\nexport function constIf<T, R>(f: F<T, R>, elf: ELF<T, R>): (cond: T) => R;\nexport function constIf<T, R>(f: F<T, R>, elf?: ELF<T, R>): (cond: T) => R | undefined;\nexport function constIf<T, R>(f: F<T, R>, elf?: ELF<T, R>): (cond: T) => R | undefined {\n  return cond => ifConst(cond, f, elf);\n}\n"],"names":["_ifConst","cond","this","check","_ref","bind","ifConst","val","compare","c","not","value","_","f","elf"],"mappings":"mPA+EA,SAASA,EAA+BC,mEAEjCC,KAAKC,MAAMF,uGAAZG,EAAyCH,GACzCD,EAASK,KAAKH,KAAMD,OAGbK,EAwBTN,EAASK,KAAK,CAAEF,MAhCY,SAACI,WAAeA,KAkChDD,EAAQE,QAAU,SAAIC,UACbT,EAASK,KAAK,CAAEF,MAAOM,KAEhCH,EAAQI,IAAM,SAAIC,UACTX,EAASK,KAAK,CAAEF,MAAO,SAACS,UAASA,IAAMD,yBC1GlBE,EAAYC,UACjC,SAAAb,UAAQK,EAAQL,EAAMY,EAAGC"}